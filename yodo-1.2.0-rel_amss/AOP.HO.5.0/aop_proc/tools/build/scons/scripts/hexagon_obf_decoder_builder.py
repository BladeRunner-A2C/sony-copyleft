'''
   Symbol Obfuscator

   GENERAL DESCRIPTION
      obf2cmm_builder is used to convert the obf map file
      generated as part of obfuscation into .cmm script as expected by Trace32
      and also into normal .txt format that will be used by CrashScope
'''
#==============================================================================
#
# Symbol Obfuscator
#
# GENERAL DESCRIPTION
#    obf2cmm_builder is used to convert the obf map file
#    generated as part of obfuscation into .cmm script as expected by Trace32,
#    and also into normal .txt format that will be used by CrashScope.
#
# Copyright (c) 2009-2020 by Qualcomm Technologies, Incorporated.
# All Rights Reserved.
# QUALCOMM Proprietary/GTDR
#
#------------------------------------------------------------------------------
#
#  $Header: //components/rel/aop.ho/5.0/aop_proc/tools/build/scons/scripts/hexagon_obf_decoder_builder.py#1 $
#  $DateTime: 2021/10/26 22:03:12 $
#  $Change: 33677139 $
#                      EDIT HISTORY FOR FILE
#
#  This section contains comments describing changes made to the module.
#  Notice that changes are listed in reverse chronological order.
#
# when       who     what, where, why
# --------   ---     ---------------------------------------------------------
# 05/10/20   svadaval      Create
#
#==============================================================================
import os
import datetime
import sys
import glob
import SCons


def exists(env):
    """
    Used by SCons to make sure scripts are not allowed to be
    loaded multiple times per environment.
    """
    return env.Detect('hexagon_obf_decoder_builder')


def generate(env):
    """
        This is the entry point called by SCons when loading this script.
        This should call other generate functions as a script might define
        multiple builders or methods.
    """
    # OBF cmm builder
    obf_to_cmm_act = env.GetBuilderAction(obf2cmm_builder)
    obf_to_cmm_bld = env.Builder(action=obf_to_cmm_act)
    env.Append(BUILDERS={'Obf2CmmBuilder': obf_to_cmm_bld})

    # OBF txt builder
    obf_to_txt_act = env.GetBuilderAction(obf2txt_builder)
    obf_to_txt_bld = env.Builder(action=obf_to_txt_act)
    env.Append(BUILDERS={'Obf2TxtBuilder': obf_to_txt_bld})


def obf2cmm_builder(target, source, env):
    """

    :param source: List of Obfuscation map files
    :param target: .cmm script to be generated in the form expected by Trace32
    :param env: Current SCons Environment
    :return:
    """
    if source:
        symdict = get_obf_symdict(env, source)
        try:
            if isinstance(target, list) and isinstance(target[0], SCons.Node.FS.File):
                target = target[0].get_path()
            with open(target, 'w') as cmm_file_handler:
                cmm_file_handler.write('// Autogenerated on {} from dictionaries: {}\n'.
                                       format(datetime.datetime.today(), source[0].get_path()))
                cmm_file_handler.write('//   {} unique symbols\n'.format(len(symdict)))
                for obf, sym in symdict.items():
                    # Note that this truncates plaintext symbols to 271 chars
                    # since T32 chokes on anything > 271 chars
                    cmm_file_handler.write('y.m.names {:<64} {:<.271}\n'.format(obf, sym))
            env.PrintInfo('Wrote {} symbols to cmm file: {}'.format(len(symdict), target))
        except IOError:
            env.PrintInfo('Could not write to cmm file: {}'.format(target))
    return None


def obf2txt_builder(target, source, env):
    """

    :param source: List of Obfuscation map files
    :param target: text file to be generated in the format expected by CrashScope.
    :param env: Current SCons Environment
    :return:
    """
    if source:
        symdict = get_obf_symdict(env, source)
        try:
            if isinstance(target, list) and isinstance(target[0], SCons.Node.FS.File):
                target = target[0].get_path()
            with open(target, 'w') as txt_file_handler:
                for obf, sym in symdict.items():
                    txt_file_handler.write('{} {}\n'.format(sym, obf))
            env.PrintInfo('Wrote {} symbols to text file: {}'.format(len(symdict), target))
        except IOError:
            env.PrintInfo('Could not write to text file: {}'.format(target))
    return None

def get_obf_symdict(env, source):
    """

    :param env: Current SCons Environment
    :param source: Obfuscation map file
    :return: Dictionary of symbols that are present in obfuscation map file
    """
    symdict = {}
    hexagon_tool_location = os.path.join(env.subst('$HEXAGON_ROOT'), env.subst('$HEXAGON_RTOS_RELEASE'))
    hexagon_tools_bin_location = os.path.join(hexagon_tool_location, "Tools" ,"bin")
    hexagon_tools_sitepkgs_location = os.path.join(hexagon_tool_location, "Tools", "lib" , "python3.7", "site-packages")
    if hexagon_tools_sitepkgs_location not in sys.path:
        sys.path.append(hexagon_tools_sitepkgs_location)
    if hexagon_tools_bin_location not in sys.path:
        sys.path.append(hexagon_tools_bin_location)
    
    # workaround for sectool six package conflict
    import imp
    imp.load_source("six", os.path.join(hexagon_tools_sitepkgs_location, "six.py"))
    
    try:
        from ObfuscationDictReader import ObfuscationDictReader
    except Exception as e:
        try:
            import ObfuscationDictReader
        except Exception as e:
            env.PrintWarning("Not able to import ObfuscationDictReader , "
                  "hence proceeding with out creating any .cmm or .txt symbol obfuscation files")
            return symdict
    for dict_file in source:
        if isinstance(dict_file, SCons.Node.FS.File):
            dict_file = dict_file.get_path()
        if not os.path.exists(dict_file):
            raise Exception('The dictionary file does not exist: {}'.format(dict_file))
        related_obf_source_list = get_all_related_obf_sources(dict_file)
        for related_obf_source in related_obf_source_list:
            # Instantiate obfuscation dictionary
            env.PrintInfo('Processing dictionary file: {}'.format(related_obf_source))
            obfuscation_dictionary = ObfuscationDictReader(related_obf_source) if callable(
                ObfuscationDictReader) else ObfuscationDictReader.ObfuscationDictReader(
                related_obf_source)

            if obfuscation_dictionary.bad():
                raise Exception('Malformed dictionary file: {}'.format(related_obf_source))

            # Read obfuscation dictionary
            try:
                obfuscation_dictionary.readDictionary()
            except:
                raise Exception('Malformed dictionary file: {}'.format(related_obf_source))


            # Read all the input files
            objfiles = obfuscation_dictionary.getInputFiles()

            # Read all the sections in those input files
            sections = obfuscation_dictionary.getObfuscatedSections(objfiles)

            # Read all the symbols in those sections
            symbols = obfuscation_dictionary.getObfuscatedSymbols(sections, objfiles)

            # Extract the plaintext and obfuscated symbol name
            for each_symbol in symbols:
                symbol_name = each_symbol.getSymbolName(each_symbol.symbol_info.symbol_name_index)
                obf_symbol_name = each_symbol.getSymbolName(each_symbol.symbol_info.obfuscated_symbol_name_index)
                symdict[obf_symbol_name] = symbol_name

            env.PrintInfo('Obfuscated symbols found: {}'.format(len(symbols)))
            env.PrintInfo('Total Unique Obfuscated Symbols found: {}'.format(len(symdict)))

    return  symdict


def get_all_related_obf_sources(source):
    file_name, file_ext = os.path.splitext(source)
    related_obf_source_list = filter(os.path.isfile,glob.glob(file_name+'*'+file_ext))
    related_obf_source_list.sort(key=lambda each_obf_file: os.path.getctime(each_obf_file))
    return related_obf_source_list
