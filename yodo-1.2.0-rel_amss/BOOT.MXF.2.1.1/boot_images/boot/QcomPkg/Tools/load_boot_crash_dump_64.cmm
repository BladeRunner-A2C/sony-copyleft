;****************************************************************************
;** load_boot_crash_dump_64.cmm
;**
;** This script performs loading of the crash dumps to a simulator.
;**
;** Copyright 2018,2020-2021 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
;**
;****************************************************************************
;**
;**                        EDIT HISTORY FOR MODULE
;**
;**
;** when       who     what, where, why
;** --------   ---     ------------------------------------------------------
;** 09/02/22   rama    Overlay backup stack to retrieve CPU context
;** 07/19/21   rama    support for loading minidumps
;** 06/22/21   rama    EL3 crashdump changes.
;** 02/19/21   rama    Ported changes.
;** 09/10/18   msantos rewritten for version 2 of sbl crash dump (Aarch64)

;****************************************************************************

; Note: Script assumes that the SBL elf is already loaded

entry &crash_dumps_path

&crash_dump_cookie=0x45525220

&default_dump_dir="C:\ProgramData\Qualcomm\QPST\Sahara\"
&dump_type="1"
&bin_filename_struct=""
&bin_filename_bootddr=""
&bin_filename_bootimem=""
&bin_filename_sharedimem=""

WINPOS 0% 50% 68% 50% 0. 0. W001
Area.create MAIN
Area.view MAIN
Area.select MAIN

print "---------------------------------------------------------------"
print "---------------SBL boot crash dump loader script---------------"
print "---------------------------------------------------------------"

;
if (!symbol.exist(boot_crash_dump_data))
(
  print "Script could not find symbols."
  print "Please load elf XBLLoader.dll, or use boot_debug.cmm."
  print "exiting"
  enddo false()
)

print
print

if os.dir("&default_dump_dir")
(
  ChDir "&default_dump_dir"
)
print "Select type of dumps to be loaded(1 for XBL_SC full dumps, 2 for XBL_SC decrypted minidumps):"
enter &dump_type
if "&dump_type"=="1"
(
&bin_filename_struct="CD_STRCT.BIN"
&bin_filename_bootddr="CD_BTDDR.BIN"
&bin_filename_bootimem="CD_BTIMM.BIN"
&bin_filename_sharedimem="CD_SHIMM.BIN"
)
if "&dump_type"=="2"
(
&bin_filename_struct="md_xbl_strct.BIN"
&bin_filename_bootddr="md_xbl_ddr.BIN"
&bin_filename_bootimem="md_xbl_imem.BIN"
&bin_filename_sharedimem="md_xbl_shrd_imm.BIN"
)
print "Select Port_COM folder containing your crash dump"
dialog.dir *
entry &crash_dumps_path
if "&crash_dumps_path"==""
(
  print "Failed to select file. Exiting..."
  &crash_dumps_path
)
print
print


; start simulator
sys.up

; load boot crash data into crash_dump_addr
d.load.binary "&crash_dumps_path\&bin_filename_struct" boot_crash_dump_data /noclear

; typecast loaded data and copy to internal trace variable for easy referencing
;var.assign boot_crash_dump_data.boot_crash_dump_aarch64_data=(boot_crash_dump_type)&crash_dump_addr

; check for the boot_crash_dump_data.boot_crash_dump_aarch64_data variable which will be used to 
; load the dumps and the registers
if (v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.crash_dump_cookie)!=&crash_dump_cookie)
(
  print "crash_dump_cookie not found in "&crash_dumps_path\&bin_filename_struct"."
  print "this binary does not contain a crash dump." 
  enddo false()
)

; currently supports version 2 of the structure.
; reference for this structure is found in the following place:
;   boot_error_handler.h    boot_crash_dump_type
if (v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.version)==2)
(
  print "found version 2 of boot crash dump data struct."
  print

  ;set elr to elr3 sec
  r.s m 0x0D
  r.s ns 0x0

  ;set saved general registers
  r.s x0 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[0])
  r.s x1 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[1])
  r.s x2 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[2])
  r.s x3 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[3])
  r.s x4 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[4])
  r.s x5 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[5])
  r.s x6 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[6])
  r.s x7 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[7])
  r.s x8 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[8])
  r.s x9 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[9])
  r.s x10 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[10])
  r.s x11 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[11])
  r.s x12 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[12])
  r.s x13 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[13])
  r.s x14 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[14])
  r.s x15 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[15])
  r.s x16 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[16])
  r.s x17 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[17])
  r.s x18 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[18])
  r.s x19 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[19])
  r.s x20 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[20])
  r.s x21 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[21])
  r.s x22 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[22])
  r.s x23 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[23])
  r.s x24 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[24])
  r.s x25 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[25])
  r.s x26 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[26])
  r.s x27 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[27])
  r.s x28 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[28])
  r.s x29 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[29])
  r.s x30 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[30])

  ;set saved system registers (or print if no way to load)
  per.set.simple spr:0x36101 %long v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.actlr_elx) ;actlr_el3 showing up as xxxx in sim
  r.s elr_el3 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.elr_elx) ;elr_el3
  per.set.simple spr:0x36520 %long v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.esr_elx) ;esr_el3
  print "far_el3: 0x", v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.far_elx) ;far_el3
  print "mair_el3: 0x", v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.mair_elx) ;mair_el3
  print "sctlr_el3: 0x", v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sctlr_elx) ;sctlr_el3
  r.s spsr_el3 v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.spsr_elx) ;spsr_el3
  print "tcr_el3: 0x", v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.tcr_elx) ;tcr_el3
  per.set.simple spr:0x36d02 %quad v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.tpidr_elx) ;tpidr_el3
  print "ttbr0_el3: 0x", v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.ttbr0_elx) ;ttbr0_el3
  per.set.simple spr:0x36c00 %quad v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.vbar_elx) ;vbar_el3

  r.s pc v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.pc) ;program counter

  ; set stack pointer last because it seems to get overwritten by some previous commands
  r.s sp v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sp_elx)

  ; set the values from boot_crash_struct
  &sbl_ddr_addr=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_ddr_addr)
  &sbl_ddr_size=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_ddr_size)
  &sbl_ddr_dump_addr=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_ddr_dump_addr)
  &sbl_boot_imem_addr=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_boot_imem_addr)
  &sbl_boot_imem_size=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_boot_imem_size)
  &sbl_boot_imem_dump_addr=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_boot_imem_dump_addr)
  &sbl_shared_imem_addr=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_shared_imem_addr)
  &sbl_shared_imem_size=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_shared_imem_size)
  &sbl_shared_imem_dump_addr=v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.sbl_shared_imem_dump_addr)

  ; put dump data into proper locations according to struct
  d.load.binary "&crash_dumps_path\&bin_filename_bootddr" &sbl_ddr_addr /noclear
  d.load.binary "&crash_dumps_path\&bin_filename_bootimem" &sbl_boot_imem_addr /noclear
  d.load.binary "&crash_dumps_path\&bin_filename_sharedimem" &sbl_shared_imem_addr /noclear
  
  ;Print boot logs
  do save_xbl_log.cmm

  if (symbol.exist(backup_stack_buf))
  (
    &stack_overlay_addr = v.value(boot_crash_dump_data.boot_crash_dump_aarch64_data.regs[29])
    data.copy backup_stack_buf++var.sizeof(backup_stack_buf) &stack_overlay_addr
  )
  print
  print "SBL crash dumps loaded."
  gosub SetupDebugWindows yes
  
  ; unroll the stack past boot_error_handler
  ;frame.up
  ;frame.up
  
  enddo true()
)
else 
(
  print "Found incompatible boot_crash_dump_type version"
  enddo false()
)

;****************************************************************************
; Setup and display the windows to debug the processor
;****************************************************************************
SetupDebugWindows:
  
  TOOLBAR ON
  STATUSBAR ON

  WINPOS 0.0 0.0 68% 65% 12. 1. W000 Normal "DATA.LIST"
  DATA.list
 
  WINPOS 68% 0. 32% 50% 0. 0. W002 Normal "REGISTERS"
  register /spotlight
 
  setup.var %open.on %hex %symbol

  WINPOS  68% 50% 32% 48% 0. 0. W003 Normal "CALL STACK"
  Var.Frame
  
  return ; SetupDebugWindows
