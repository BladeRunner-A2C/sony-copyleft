/*
 * Copyright 2010 Sony Corporation
 */

/**
 * @brief Configuration Handling
 *
 * There are many configurations. This is about one, and that's the
 * configuration that we download from the server, and then pass
 * to our clients.
 *
 * The configuration is saved as one file per section. A list is used
 * to map between name/package and file. If a configuration section that
 * was available in the previous configuration is missing in the latest
 * one, the value is defaulted.
 *
 * @author Victor Boivie (victor.boivie@sonyericsson.com)
 */
#include <cutils/properties.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <zlib.h>
#include <openssl/sha.h>
#include <sys/wait.h>
#include <sys/inotify.h>
#include <sys/prctl.h>
#include "configuration.h"
#include "config.h"
#include "serializer.h"
#include "protos/configuration.pb-c.h"
#include "list.h"
#include "util.h"
#include "filter.h"
#include "settings.h"
#include "crypto.h"
#include "protos/idd/iddd.pb-c.h"
#include "plugins.h"

#define LOG_TAG "iddd-conf"
#include "logging.h"

#define BUFFER_SIZE 64

typedef struct {
  const char* package_p;
  const char* name_p;
} idd_config_key_t;

typedef struct {
  idd_config_key_t key;
  int id;
  int active; // 1 if the configuration item is currently available, otherwise 0
} idd_config_t;

static idd_list_t* config_list_p = NULL;

// The tag number of the device_id in the ConfigRequest protobuf.
#define TAG_NR_DEVICE_ID_CR 3

#define CONFIG_NOTIFY_NAME PRIVATE_DIR_NAME "config_changed"

/**
 *
 */
int config_request_get(char* buf_p, int max_size)
{
  char serialized[IDD_MAX_DEVICE_ID_SIZE * 2] = {0};
  const char *str_p;
  int header_size = (int)get_report_header(&str_p);
  if ((header_size <= 0) || (header_size > max_size))
  {
    IDD_LOGE("Configuration request: Bad header size %d", header_size);
    return CONFIG_REQ_ERROR;
  }
  memcpy(buf_p, str_p, header_size);

  str_p = get_device_id_cr();
  size_t size = serialize_string(serialized, sizeof(serialized), str_p,
                                 strnlen(str_p, IDD_MAX_DEVICE_ID_SIZE),
                                 TAG_NR_DEVICE_ID_CR);
  if (((int)size + header_size) > max_size) {
    IDD_LOGE("Configuration request: To large protobuf (%zu + %d) > %d",
              size, header_size, max_size);
    return CONFIG_REQ_ERROR;
  }
  memcpy(buf_p + header_size, serialized, size);
  return header_size + size;
}

/**
 * Get a file descriptor that will receive notification when a new
 * configuration is loaded.
 *
 * @return file descriptor, -1 on failure
 */
int config_change_notify_get(void)
{
  int fd = inotify_init();
  if (fd != -1)
  {
    int test = open(CONFIG_NOTIFY_NAME, O_RDONLY | O_CREAT, S_IRUSR | S_IWUSR);
    if (test == -1)
    {
      close(fd);
      return -1;
    }
    close(test);
    test = inotify_add_watch(fd, CONFIG_NOTIFY_NAME, IN_CLOSE_WRITE);
    IDD_LOGI("config_change_notify_get: test = %d", test);
    if (test == -1)
    {
      IDD_LOGE("inotify_add_watch failed: %s", strerror(errno));
      close(fd);
      return -1;
    }
  }
  return fd;
}

/**
 * Trigger an event on all file descriptors generated by config_change_notify_get().
 *
 */
static void notify_new_config(void)
{
  int fd = open(CONFIG_NOTIFY_NAME, O_WRONLY | O_TRUNC);
  if (fd >= 0)
  {
    close(fd);
  }
}

/**
 * Writes a new configuration, into file "input/config"
 *
 */
void write_config(const char* config_p, size_t config_size)
{
  FILE* config_file = fopen(PUBLIC_CONFIG_FNAME, "wb");
  if (config_file == NULL)
  {
    IDD_LOGE("Failed to create configuration file: %s", strerror(errno));
  }
  else
  {
    int fd = fileno(config_file);
    IDD_LOGD("Writing configuration file");
    if (write_all(fd, config_p, config_size) < 0)
    {
      IDD_LOGE("Failed to write configuration file: %s", strerror(errno));
    }
    fclose(config_file);
  }
}

/**
 * Save a configuration into file "private/configs_backup/config_recovery,
 * in case of recovery for mismatched user consent configuration"
 *
 */
void save_recovery_config(void)
{
  FILE* config_file = fopen(PUBLIC_CONFIG_FNAME, "rb");
  if (config_file == NULL)
  {
    IDD_LOGE("Failed to open input configuration: %s", strerror(errno));
  }
  else
  {
    size_t config_size;
    unsigned char* config_p = read_entire_file(config_file, &config_size);
    if (config_p != NULL)
    {
      FILE* recovery_config_file = fopen(PRIVATE_CONFIG_RECOVERY_FNAME, "wb");
      if (recovery_config_file != NULL)
      {
        int recovery_config_fd = fileno(recovery_config_file);
        IDD_LOGD("Saving recovery configuration");
        if (write_all(recovery_config_fd, config_p, config_size) < 0)
        {
          IDD_LOGE("Failed to save recovery configuration: %s", strerror(errno));
        }
        fclose(recovery_config_file);
      }
      free(config_p);
    }
    fclose(config_file);
  }
}

/**
 * Load recovery configuration, from file "private/configs_backup/config_recovery"
 *
 * @retval 1 Recovery configuration is successfully loaded
 * @retval 0 Otherwise
 */
int load_recovery_config(void)
{
  int ret = 0;
  FILE* config_file = fopen(PRIVATE_CONFIG_RECOVERY_FNAME, "rb");
  if (config_file == NULL)
  {
    IDD_LOGD("Recovery configuration is not saved or missing");
  }
  else
  {
    size_t config_size;
    unsigned char* config_p = read_entire_file(config_file, &config_size);
    if (config_p != NULL)
    {
      IDD_LOGD("Loading recovery configuration");
      write_config((const char*)config_p, config_size);
      free(config_p);
      ret = 1;
    }
    fclose(config_file);
  }
  return ret;
}

/**
 * Save a new anonymous configuration, into file "private/configs_backup/config_anonymous"
 *
 */
void save_anonymous_config(void)
{
  FILE* config_file = fopen(PUBLIC_CONFIG_FNAME, "rb");
  if (config_file == NULL)
  {
    IDD_LOGE("Failed to open anonymous configuration: %s", strerror(errno));
  }
  else
  {
    size_t config_size;
    unsigned char* config_p = read_entire_file(config_file, &config_size);
    if (config_p != NULL)
    {
      FILE* anon_config_file = fopen(PRIVATE_CONFIG_ANONYMOUS_FNAME, "wb");
      if (anon_config_file != NULL)
      {
        int anon_config_fd = fileno(anon_config_file);
        IDD_LOGD("Saving anonymous configuration");
        if (write_all(anon_config_fd, config_p, config_size) < 0)
        {
          IDD_LOGE("Failed to save anonymous configuration: %s", strerror(errno));
        }
        fclose(anon_config_file);
      }
      free(config_p);
    }
    fclose(config_file);
  }
}

/**
 * Load anonymous configuration, from file "private/configs_backup/config_anonymous"
 *
 * @retval 1 Anonymous configuration is successfully loaded
 * @retval 0 Otherwise
 */
int load_anonymous_config(void)
{
  int ret = 0;
  FILE* config_file = fopen(PRIVATE_CONFIG_ANONYMOUS_FNAME, "rb");
  if (config_file == NULL)
  {
    IDD_LOGD("Anonymous configuration is not saved or missing");
  }
  else
  {
    size_t config_size;
    unsigned char* config_p = read_entire_file(config_file, &config_size);
    if (config_p != NULL)
    {
      IDD_LOGD("Loading anonymous configuration");
      write_config((const char*)config_p, config_size);
      free(config_p);
      ret = 1;
    }
    fclose(config_file);
  }
  return ret;
}

/**
 * Delete all files in the "input" directory.
 *
 */
static void purge_input_dir(void)
{
  DIR* dir_p = opendir(INPUT_DIR_NAME);

  if (dir_p != NULL)
  {
    struct dirent* de_p;

    IDD_LOGD("Purging input directory");

    while ((de_p = readdir(dir_p)) != NULL)
    {
      char name[PATH_MAX] = {0};

      if (strcmp(de_p->d_name, ".") == 0 || strcmp(de_p->d_name, "..") == 0)
      {
        continue;
      }

      snprintf(name, sizeof(name), "%s%s", INPUT_DIR_NAME, de_p->d_name);

      IDD_LOGD("Deleting %s", name);
      if (unlink(name) == -1)
      {
        IDD_LOGW("Failed to delete %s.", name);
      }
    }
    closedir(dir_p);
  }
}

/**
 * Check if the next char read from file 'fp' is a protobuf field
 * with a given number.
 *
 * @param fp file to read from
 * @param field_nr expected protobuf field number
 *
 * @return 1 if field is 'field_nr', else 0
 */
static int is_field(FILE* fp, int field_nr)
{
#define WIRE_TYPE_LENGTH_DELIMITED 2
  int c = getc(fp);
  if (c != ((field_nr) << 3 | WIRE_TYPE_LENGTH_DELIMITED))
  {
    ungetc(c, fp);
    return 0;
  }
  return 1;
}

/**
 * Copy from the current location in file 'in_fp' to 'output_p' file.
 *
 * @param in_fp file to read from
 * @param output_p name of file to write to
 * @param bytes_left number of bytes to copy
 *
 * @return none 0 if successful
 */
static int extract_file_part(FILE* in_fp, const char* output_p, int bytes_left)
{
  FILE* out_fp = fopen(output_p, "wb");
  if (out_fp != NULL)
  {
    char buffer[2048] = {0};
    int bytes_read;

    while (bytes_left > 0)
    {
      int bytes_to_read = MIN((int)sizeof(buffer), bytes_left);
      bytes_read = (int)fread(buffer, 1, bytes_to_read, in_fp);
      if ((bytes_read != bytes_to_read) ||
          (int)fwrite(buffer, 1, bytes_read, out_fp) != bytes_read)
      {
        break;
      }
      bytes_left -= bytes_read;
    }
    fclose(out_fp);
  }
  return bytes_left == 0;
}

/**
 * Extract the length of the data for a protobuf field.
 *
 * @param fp file to read from
 * @param len max file position
 * @param value_p length of the protobuf field, out parameter
 *
 * @return change in file offset
 */
static int read_varint32(FILE* fp, int len, int* value_p)
{
  int max_bytes = len < 5 ? len : 5;
  int value = 0;
  int i;
  int shift = 0;

  for (i = 0; i < max_bytes; i++)
  {
    int c = getc(fp);
    value |= (c & 0x7f) << shift;
    shift += 7;
    if ((c & 0x80) == 0)
    {
      break;
    }
  }

  if (i == max_bytes)
  {
    return -1;
  }

  *value_p = value;
  return i;
}

/**
 * Read a protobuf byte field from a file and write to another file.
 *
 * @param fp file to read from
 * @param field_nr field number in proto file
 * @param fname_p name of file to write field content to
 * @param len length of file 'fp'
 *
 * @return -1 if failure, 0 if 'field_nr' is not present in 'fp', 1 if
 * it is present and could be extracted
 */
static int extract_byte_field(FILE* fp, int field_nr, const char* fname_p, int len)
{
  if (is_field(fp, field_nr))
  {
    int field_length;
    int off = 1; // The tag's size
    int length_size = read_varint32(fp, len - off, &field_length);

    off += length_size;

    if ((length_size == -1) || (field_length > (len - off)))
    {
      IDD_LOGE("Corrupt file - bad field length");
      return -1;
    }

    if (!extract_file_part(fp, fname_p, field_length))
    {
      IDD_LOGE("Failed to extract to %s", fname_p);
      return -1;
    }
    return 1;
  }
  return 0;
}

/**
 * Open "input/config", read the signature (if any) and write it to
 * "private/new_config.sig" and then read the ConfigPackage (as
 * defined in configuration..proto) putting it in
 * "private/new_config.gz".
 *
 * @return 1 if successful, else 0
 */
static int unpack_config_to_private(void)
{
  int ret = 0;
  FILE* in_fp = fopen(PUBLIC_CONFIG_FNAME, "rb");
  if (in_fp != NULL)
  {
    size_t len;
    (void)get_file_size(in_fp, &len);
    IDD_LOGD("Unpacking config to private directory");
    // Don't try to process files that are too big.
    if ((len > 0) && (len < MAX_CONFIG_SIZE))
    {
      // The signature is optional, so this function may return 0 and that's ok.
      int sig_ret = extract_byte_field(in_fp, 1, PRIVATE_CONFIG_SIG_FNAME, len);
      IDD_LOGD("Signature extraction: %d", sig_ret);
      if (sig_ret >= 0)
      {
        // The payload is mandatory, so this function must return 1
        int data_ret = extract_byte_field(in_fp, 2, PRIVATE_CONFIG_FNAME, len);
        IDD_LOGD("Data extraction: %d", data_ret);
        if (data_ret > 0)
        {
          // We are done parsing the file. There may be more fields, and they
          // might even be invalid. But we don't support them and don't care.
          ret = 1;
        }
      }
    }
    fclose(in_fp);
  }
  else
  {
    IDD_LOGE("Failed to open configuration %s <%s>", PUBLIC_CONFIG_FNAME, strerror(errno));
  }
  return ret;
}

/**
 * Verify the integrity of "private/new_config.gz".
 *
 * @return 1 if successful, else 0
 */
static int verify_config(void)
{
  // Only verify if we have a certificate.
  if (is_verification_active())
  {
    IDD_LOGD("Verifying using certificate");
    return crypto_verify_config(PRIVATE_CONFIG_FNAME, PRIVATE_CONFIG_SIG_FNAME);
  }

  // If we don't have a certificate, proceed and grant access.
  // This either means that we're running a development version,
  // or the phone is compromised, and then we're screwed anyway.
  return 1;
}

/**
 * Remove "input/config", "private/new_config.gz" and "private/new_config.sig".
 *
 */
static void cleanup_config(void)
{
  IDD_LOGD("Cleaning up configuration files");
  unlink(PUBLIC_CONFIG_FNAME);
  unlink(PRIVATE_CONFIG_FNAME);
  unlink(PRIVATE_CONFIG_SIG_FNAME);
}

#define DECOMPRESS_CHUNK_SIZE 16384

/**
 * Read configuration from "private/new_config.gz" and decompress it.
 *
 * @param buffer_pp decompressed file content, out parameter
 * @param size_p size of 'buffer_pp', out parameter
 *
 * @return 1 if successful, else 0
 */
static int read_config(char** buffer_pp, size_t* size_p)
{
  char* buf_p = NULL;
  size_t buf_size = 0;
  int ret = 0;
  gzFile input_gz = gzopen(PRIVATE_CONFIG_FNAME, "rb");
  IDD_LOGD("Decompressing configuration file");
  if (input_gz != NULL)
  {
    for (;;)
    {
      int bytes_read;
      char* new_buf_p = realloc(buf_p, buf_size + DECOMPRESS_CHUNK_SIZE);
      if (new_buf_p == NULL)
      {
        break;
      }
      buf_p = new_buf_p;
      bytes_read = gzread(input_gz, &buf_p[buf_size], DECOMPRESS_CHUNK_SIZE);
      buf_size += bytes_read;
      if (bytes_read < DECOMPRESS_CHUNK_SIZE)
      {
        break;
      }
    }
    ret = gzeof(input_gz);
    gzclose(input_gz);
  }
  if (!ret)
  {
    free(buf_p);
  }
  else
  {
    *buffer_pp = buf_p;
    *size_p = buf_size;
  }
  IDD_LOGD("Decompressing done.");
  return ret;
}

/**
 * Create a new idd_config_t element.
 *
 * @param package_p name of the package for the configuration item
 * @param name_p name of the configuration item
 *
 * @return a pointer to a new idd_config_t element if successful, else NULL
 */
static idd_config_t* create_config_item(const char* package_p, const char* name_p)
{
  size_t package_size = strlen(package_p);
  size_t name_size = strlen(name_p);
  idd_config_t* config_p = malloc(sizeof(*config_p) + package_size + 1 + name_size + 1);

  if (config_p != NULL)
  {
    char* config_package_p = (char*)config_p + sizeof(*config_p);
    char* config_name_p = config_package_p + package_size + 1;
    config_p->key.package_p = config_package_p;
    config_p->key.name_p = config_name_p;
    memcpy(config_package_p, package_p, package_size + 1);
    memcpy(config_name_p, name_p, name_size + 1);
  }
  return config_p;
}

/**
 * Get a new config item ID to use, or <= 0 if an ID could not be
 * constructed.
 *
 */
static int get_id(void)
{
  static const idd_config_key_t key = {"iddd", "_last_id"};
  idd_config_t* id_p = list_find(config_list_p, (void*)&key);
  if (id_p != NULL)
  {
    return ++id_p->id;
  }

  id_p = create_config_item(key.package_p, key.name_p);

  if (id_p == NULL)
  {
    return 0;
  }
  id_p->id = 1;
  id_p->active = 0;

  if (list_add(config_list_p, (void**)&id_p))
  {
    return 1; // The ID of the newly created item - id_p is NULL now.
  }

  return 0;
}

/**
 * Adds a new config item to 'config_list_p'.
 *
 * @param package_p name of the package for the configuration item
 * @param name_p name of the configuration item
 *
 * @return a pointer to a new idd_config_t element if successful, else NULL
 */
static idd_config_t* add_new_config_item(const char* package_p, const char* name_p)
{
  idd_config_t* config_p = create_config_item(package_p, name_p);

  if (config_p != NULL)
  {
    config_p->id = get_id();
    config_p->active = 1;

    if (config_p->id <= 0)
    {
      free(config_p);
      config_p = NULL;
    }
    else
    {
      if (!list_add(config_list_p, (void**)&config_p))
      {
        IDD_LOGE("Failed to add new config item: list_add.");
      }
    }
  }
  return config_p;
}

/**
 * Find a configuration item in 'config_list_p'.
 *
 * @param package_p name of the package for the configuration item
 * @param name_p name of the configuration item
 *
 * @return a pointer to the found idd_config_t element, else NULL
 */
static idd_config_t* get_config_item(const char* package_p, const char* name_p)
{
  idd_config_key_t key;
  idd_config_t* item_p;
  key.package_p = package_p;
  key.name_p = name_p;
  item_p = list_find(config_list_p, &key);

  return item_p;
}

/**
 * Implementation of the callback idd_list_iterate_t from list.h
 *
 * @param element_p idd_config_t element to change active state for
 * @param userdata_p active or not (int)
 */
static void set_all_config_items_active_cb(const void* element_p, void* userdata_p)
{
  idd_config_t* item_p = (idd_config_t*) element_p;
  int active = *((int*) userdata_p);
  item_p->active = active;
}

/**
 * Sets all config items to active/inactive mode according to parameter.
 *
 * @param active
 */
static void set_all_config_items_active(int active)
{
  list_iterate(config_list_p, set_all_config_items_active_cb, (void*) &active);
}

/**
 * Remove the "conf_nnn.bin" file corresponding to the specified
 * idd_config_t element if the configuration item is not active and
 * doesn't belong to iddd itself and isn't the element tracking the
 * last used id. Implementation of the callback idd_list_iterate_t
 * from list.h.
 *
 * @param element_p pointer to idd_config_t element
 * @param userdata_p not used, always NULL
 */
static void remove_unused_config_files_cb(const void* element_p,
    void* userdata_p)
{
  (void)userdata_p;
  idd_config_t* item_p = (idd_config_t*) element_p;
  if (!(item_p->active) && !(strcmp(item_p->key.package_p, "iddd") == 0
      && strcmp(item_p->key.name_p, "_last_id") == 0))
  {
    char name[PATH_MAX] = {0};
    snprintf(name, sizeof(name), CONFIG_PART_FNAME, item_p->id);

    IDD_LOGD("Removing unused conf file %s", name);
    unlink(name);
  }
}

/**
 * Remove all config files related to inactive config items.
 *
 */
static void remove_unused_config_files()
{
  list_iterate(config_list_p, remove_unused_config_files_cb, NULL);
}

static int get_config_file_path_internal(idd_config_t* item_p, char* out_path_p, int out_path_size) {
  if (item_p == NULL) return 0;
  if (!item_p->active) return 0;
  snprintf(out_path_p, out_path_size, CONFIG_PART_FNAME, item_p->id);
  return 1;
}

int get_config_file_path(const char* package_p, const char* name_p, char* out_path_p, int out_path_size)
{
  idd_config_t* item_p = get_config_item(package_p, name_p);
  return get_config_file_path_internal(item_p, out_path_p, out_path_size);
}

/**
 * Opens the configuration file for the specific package and name for
 * reading.
 *
 * @param package_p name of the package
 * @param name_p name of the configuration item
 *
 * @return file pointer to the config file ("conf_nnn.bin"), NULL if
 * the configuration item is not active or the file couldn't be opened
 */
FILE* config_open_file(const char* package_p, const char* name_p)
{
  FILE* fp = NULL;
  idd_config_t* item_p = get_config_item(package_p, name_p);

  char name[PATH_MAX] = {0};
  if (get_config_file_path_internal(item_p, name, sizeof(name)))
  {
    fp = fopen(name, "rb");
  }
  return fp;
}

/**
 * If this is a new config item (i.e. a ConfigPart defined in
 * configuration.proto) then create an idd_config_t element and insert
 * it into 'config_list_p'. Irrespective if the element is new or not,
 * activate it and write the payload of the ConfigPart protobuf to
 * file "conf_nnn.bin" where 'nnn' is the id of the config element.
 *
 * @param part_p
 */
static void handle_config_part(Idd__Config__ConfigPart* part_p)
{
  // Save this part to disk, possibly replacing an old one.
  if (part_p->package != NULL && part_p->name != NULL)
  {
    idd_config_t* item_p = get_config_item(part_p->package, part_p->name);
    if (item_p == NULL)
    {
      // This config part is received for the first time.
      item_p = add_new_config_item(part_p->package, part_p->name);
    }
    if (item_p != NULL)
    {
      item_p->active = 1;

      char name[PATH_MAX] = {0};
      // We don't want to use config_open_file here, since we need to be able
      // to write to the file.
      snprintf(name, sizeof(name), CONFIG_PART_FNAME, item_p->id);

      FILE* fp = fopen(name, "wb");
      if (fp != NULL)
      {
        IDD_LOGD("Writing conf file %d for %s::%s, %zu bytes data", item_p->id,
                 part_p->package, part_p->name, part_p->payload.len);

        size_t bytes_written = fwrite(part_p->payload.data, 1, part_p->payload.len, fp);
        fclose(fp);

        if (bytes_written != part_p->payload.len)
        {
          IDD_LOGE("Failed to write config %d with %zu bytes", item_p->id, part_p->payload.len);
          unlink(name);
        }
      }
    }
  }
}

/**
 * Implementation of the callback idd_list_load_t from list.h. We
 * extract three string values from the passed parameter.
 *
 * @param this_record_p pointer to the first string item
 * @param next_record_p pointer to the next string item
 * @param userdata_p always NULL
 *
 * @return a pointer to a new idd_config_t element
 */
static void* load_config_list_cb(char* this_record_p, char* next_record_p, void* userdata_p)
{
  const char* package_p = NULL;
  const char* name_p = NULL;
  const char* id_p = NULL;
  const char* active_p = NULL;
  idd_config_t* config_p = NULL;

  (void)userdata_p;

  package_p = this_record_p;
  this_record_p += strlen(this_record_p) + 1;
  if (this_record_p < next_record_p)
  {
    name_p = this_record_p;
    this_record_p += strlen(this_record_p) + 1;

    if (this_record_p < next_record_p)
    {
      id_p = this_record_p;
      this_record_p += strlen(this_record_p) + 1;

      if (this_record_p < next_record_p)
      {
        active_p = this_record_p;
        this_record_p += strlen(this_record_p);

        if (this_record_p == next_record_p)
        {
          config_p = create_config_item(package_p, name_p);
          if (config_p != NULL)
          {
            config_p->id = atoi(id_p);
            config_p->active = atoi(active_p);
            IDD_LOGD("Loading config: %s::%s = %d", package_p, name_p, config_p->id);
          }
        }
        else
        {
          //The last token (value) is too long
          IDD_LOGE("Failed to parse config line.");
        }
      }
    }
  }

  return config_p;
}

/**
 * Implementation of the callback idd_list_save_t from list.h.
 *
 * @param fp file to write to
 * @param element_p pointer to the idd_config_t element to serialize
 * @param userdata_p always NULL
 *
 * @return 1 if success, 0 if failure
 */
static int save_config_list_cb(FILE* fp, const void* element_p, void* userdata_p)
{
  idd_config_t* config_p = (idd_config_t*)element_p;

  (void)userdata_p;

  if(fprintf(fp, "%s%c%s%c%d%c%d%c%c%c", config_p->key.package_p, 0, config_p->key.name_p,
      0, config_p->id, 0, config_p->active, 0, 0, '\n') < 0)
  {
    IDD_LOGE("Failed to write to configuration list file.");
    return 0;
  }

  return 1;
}

/**
 * Compare two idd_config_key_t elements on package and name.
 *
 * @param lhs_p pointer to first idd_config_key_t element
 * @param rhs_p pointer to second idd_config_key_t element
 *
 * @return 0 if equal, normal strcmp semantics
 */
static int compare_config(const void* lhs_p, const void* rhs_p)
{
  const idd_config_key_t* key1_p = (const idd_config_key_t*)lhs_p;
  const idd_config_key_t* key2_p = (const idd_config_key_t*)rhs_p;

  int diff = strcmp(key1_p->package_p, key2_p->package_p);
  if (diff == 0)
  {
    diff = strcmp(key1_p->name_p, key2_p->name_p);
  }

  return diff;
}

/**
 * Called from main() to create and load 'config_list_p' from file
 * "config_list.txt".
 *
 */
static void load_config_list(void)
{
  config_list_p = list_create(CONFIG_LIST_INITIAL_SIZE,
                              CONFIG_LIST_GROW_BY,
                              compare_config,
                              NULL);
  if (config_list_p == NULL)
  {
    die("OOM, while creating config_list_p");
  }

  list_load(config_list_p, CONFIG_LIST_FNAME, load_config_list_cb, NULL);
}

/**
 * Saves configuration list to file.
 *
 * @return 0 on failure and non-zero on success.
 */
static int save_config_list(void)
{
  IDD_LOGD("Saving configuration list");
  return list_save(config_list_p, CONFIG_LIST_FNAME, save_config_list_cb, NULL);
}

/**
 * Unpack the passed buffer as a ConfigPackage protobuf (defined in
 * configuration.proto). *
 * @param buf_p ConfigPackage protobuf
 * @param size size of the protobuf
 *
 * @return 0 on failure, 1 on success
 */
static int parse_config(const char* buf_p, size_t size)
{
  Idd__Config__ConfigPackage* cp_p =
    idd__config__config_package__unpack(NULL, size, (uint8_t*)buf_p);

  if (cp_p != NULL)
  {

    set_all_config_items_active(0);

    size_t i;
    IDD_LOGD("Configuration has %zu parts", cp_p->n_parts);
    for (i = 0; i < cp_p->n_parts; i++)
    {
      Idd__Config__ConfigPart* part_p = cp_p->parts[i];

      if (part_p != NULL)
      {
        handle_config_part(part_p);
      }
    }
    idd__config__config_package__free_unpacked(cp_p, NULL);
    if (save_config_list())
    {
      remove_unused_config_files();
      return 1;
    }
  }
  return 0;
}

/**
 * Compute a checksum for a new configuration.
 *
 * @param checksum_p out buffer to receive the checksum, must have
 * size=CONFIG_CHECKSUM_LEN
 *
 * @return 0 on failure
 */
static int generate_checksum(char* checksum_p)
{
  int ret = 0;
  SHA_CTX ctx;
  FILE* fp = fopen(PUBLIC_CONFIG_FNAME, "rb");

  if (fp != NULL)
  {
    if (SHA1_Init(&ctx))
    {
      unsigned char buffer[2048] = {0};
      size_t bytes_read;
      while ((bytes_read = fread((char*)buffer, 1, sizeof(buffer), fp)) > 0)
      {
        SHA1_Update(&ctx, buffer, bytes_read);
      }
      ret = (feof(fp) && SHA1_Final((unsigned char*)checksum_p, &ctx));
    }
    fclose(fp);
  }
  return ret;
}

/**
 * Stop/start/Reload the idd logreader in response to a received
 * configuration (see run_configuration_actions() below).
 *
 * @param should_run
 */
static void run_log_reader(int should_run)
{
  static pid_t log_reader_pid = 0;
  IDD_LOGD("Run log reader? %s - pid=%d", should_run ? "Yes" : "No", log_reader_pid);

  // If log reader is running, we need to kill it to be able to restart it.
  if (log_reader_pid > 0)
  {
    if (!should_run)
    {
      if (kill(log_reader_pid, SIGTERM) == 0)
      {
        IDD_LOGD("Waiting for log-reader to stop");
        waitpid(log_reader_pid, NULL, 0);
        IDD_LOGD("Log-reader has stopped");
      }
      log_reader_pid = 0;
    }
    else
    {
      /* Verify that the logreader is running */
      should_run = 0;
      if (kill(log_reader_pid, 0) == -1)
      {
        int errno_tmp = errno;
        IDD_LOGE("Check running signal failed to idd-logreader, %d, %s",
                  errno_tmp, strerror(errno_tmp));
        if (errno_tmp == ESRCH)
        {
          /* If the errno is ESRCH (No such process), the logreader is not running, restart it */
          should_run = 1;
        }
      }
      else
      {
        IDD_LOGD("Check running signal sent to idd-logreader");
      }
    }
  }

  // Should we then start it?
  if (should_run)
  {
    log_reader_pid = fork();
    if (log_reader_pid == -1)
    {
      IDD_LOGE("Failed to start log reader");
    }
    else if (log_reader_pid == 0)
    {
      // We are the child. Which will now execute the log reader
      char* envp[] = {NULL};
      char* args[] = {"/vendor/bin/idd-logreader", "main", NULL};
      IDD_LOGD("About to start log reader with pid %d", getpid());
      //Deathsignal to child process, when parent dies
      prctl(PR_SET_PDEATHSIG, SIGTERM);
      // NOTE: If we are running in test mode, we are not running
      // from the default paths. Hard coded right now, unfortunately.
      if (execve(args[0], args, envp) == -1)
      {
        IDD_LOGE("Failed to execute log reader: %s", strerror(errno));
      }
      exit(1);
    }
  }
}

/**
 * Runs additional actions that IDDD has been asked to perform by a
 * configuration part (message 'RunActions' in iddd.proto).
 *
 */
void run_configuration_actions(void)
{
  FILE* fp = config_open_file("iddd", "RunActions");
  if (fp != NULL)
  {
    IDD_LOGD("Running actions from fd = %d", fileno(fp));
    size_t size;
    unsigned char* buf_p = read_entire_file(fp, &size);
    fclose(fp);
    if (buf_p != NULL)
    {
      Iddd__RunActions* ra_p = iddd__run_actions__unpack(NULL, size, buf_p);
      if (ra_p != NULL)
      {
        run_log_reader(ra_p->run_log_reader);
        iddd__run_actions__free_unpacked(ra_p, NULL);
      }
      free(buf_p);
    }
  }
  IDD_LOGD("Running actions, end");
}

/**
 * remove reports in response to a received
 * configuration (see run_configuration_actions_once() below).
 *
 * @param should_run
 */
static void run_remove_reports(int should_run)
{
  IDD_LOGD("Run remove reports? %d", should_run);
  // Should we then start it?
  if (should_run)
  {
    remove_report(0);
  }
}

/**
 * Specifies actions that IDDD should perform
 * only once when this configuration is downloaded.
 */
void run_configuration_actions_once(void)
{
  FILE* fp = config_open_file("iddd", "RunActionsOnce");
  if (fp != NULL)
  {
    IDD_LOGD("Running actions from fd = %d only once", fileno(fp));
    size_t size;
    unsigned char* buf_p = read_entire_file(fp, &size);
    fclose(fp);
    if (buf_p != NULL)
    {
      Iddd__RunActionsOnce* ra_p = iddd__run_actions_once__unpack(NULL, size, buf_p);
      if (ra_p != NULL)
      {
        run_remove_reports(ra_p->remove_reports);
        idd_config_t* item_p = get_config_item("iddd", "RunActionsOnce");
        if (item_p != NULL && item_p->active)
        {
          item_p->active = 0;
        }
        iddd__run_actions_once__free_unpacked(ra_p, NULL);
      }
      free(buf_p);
    }
  }
  IDD_LOGD("Running actions only once, end");
}

/**
 * Perform actions when a new IDD configuration has been loaded.
 *
 * @param config_changed True if the configuration has changed but not if this is the device first
 *                       configuration.
 */
static void new_configuration_actions(int config_changed)
{
  if (config_changed)
  {
   // Run startup_prober when a new IDD configuration is loaded.
    property_set("vendor.idd.startupprober.start", "1");
  }
}


/**
 * Load a new configuration, if available, from "input/config".
 * Called from main() and when the "NC" command is received from the agent.
 *
 * @param force If 1 then load a new configuration regardless of
 *              user consent mismatching.
 * @retval 1 New configuration is verified ok
 * @retval 0 Otherwise
 */
int load_new_configuration(int force)
{
  int ret = 0;
  char checksum[CONFIG_CHECKSUM_LEN] = {0};
  IDD_LOGD("load_new_configuration start");

  if (generate_checksum(checksum))
  {
    if (unpack_config_to_private())
    {
      if (verify_config())
      {
        char* data_p = NULL;
        size_t size = 0;
        if (read_config(&data_p, &size))
        {
          if (parse_config(data_p, size))
          {
            int config_changed = set_config_checksum(checksum);
            settings_load_configuration();

            if (needs_save_anonymous_config())
            {
              save_anonymous_config();
            }

            if (is_required_user_consent_matched() || force)
            {
              save_recovery_config();
              filter_load_configuration(g_filter);
              run_configuration_actions();
              run_configuration_actions_once();
              plugins_load_configuration();

              notify_new_config();
              new_configuration_actions(config_changed);
              ret = 1;
            }
            else
            {
              load_recovery_config() ? : load_default_iddd_config(1);
              load_new_configuration(1);
            }
          }
          else
          {
            IDD_LOGE("Failed to parse configuration");
          }
          free(data_p);
        }
        else
        {
          IDD_LOGE("Failed to read configuration");
        }
      }
      else
      {
        IDD_LOGE("Failed to verify configuration");
      }
    }
    else
    {
      IDD_LOGE("Failed to unpack configuration");
    }
    cleanup_config();
  }
  purge_input_dir();
  IDD_LOGD("load_new_configuration end");
  return ret;
}

/* Initializes the configuration module and
 * loads persistent state from disk.
 */
void config_init(void)
{
  load_config_list();

  if (!filter_init(g_filter))
  {
    load_default_iddd_config(0);
  }
}

/**
 * Destroy the global list containing all configurations
 * ('config_list_p').
 *
 */
void config_shutdown(void)
{
  if (config_list_p != NULL)
  {
    list_destroy(&config_list_p);
  }
}

/**
 * Load iddd.conf from /vendor/etc/ to input folder and rename as config
 * This will be treated as the input of load_new_configuration.
 *
 * @param force If 1 then load iddd.conf in disregard of exisiting input configuration
 */
void load_default_iddd_config(int force)
{
  char buffer[BUFFER_SIZE] = {0};
  FILE *from_fp, *to_fp;
  size_t len;

  const char* p_default_config_flie = DEFAULT_DAEMON_USER_CONFIG_FNAME;
  if (!is_user_variant()) p_default_config_flie = DEFAULT_DAEMON_DEBUG_CONFIG_FNAME;

  IDD_LOGD("Load default configuration from %s to %s", p_default_config_flie, PUBLIC_CONFIG_FNAME);
  // The existing input configuration will be treated as the input of load_new_configuration
  if (access(PUBLIC_CONFIG_FNAME, F_OK) == 0 && !force)
  {
    IDD_LOGD("Since input configuration has already existed: %s, no need to load default.", PUBLIC_CONFIG_FNAME);
    return;
  }

  // Load the default configuration file of iddd as the input of load_new_configuration
  from_fp = fopen(p_default_config_flie, "rb");
  if (from_fp == NULL)
  {
    IDD_LOGE("Failed to open %s. %s", p_default_config_flie, strerror(errno));
    return;
  }

  to_fp = fopen(PUBLIC_CONFIG_FNAME, "wb");
  if (to_fp == NULL)
  {
    fclose(from_fp);
    IDD_LOGE("Failed to open input configuration: %s", strerror(errno));
    return;
  }

  while ((len = fread(buffer, 1, BUFFER_SIZE, from_fp)) > 0)
  {
    fwrite(buffer, 1, len, to_fp);
  }
  fclose(from_fp);
  fclose(to_fp);
}
