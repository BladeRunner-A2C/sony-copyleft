;****************************************************************************
;** load_boot_crash_dump.cmm
;**
;** This script performs loading of the crash dumps to a simulator.
;**
;** Copyright 2018,2020-2023 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
;**
;****************************************************************************
;**
;**                        EDIT HISTORY FOR MODULE
;**
;**
;** when       who     what, where, why
;** --------   ---     ------------------------------------------------------
;** 03/02/23   krd     Cleaned changes for the arm
;** 02/19/21   rama    Ported changes
;** 09/10/18   msantos rewritten for version 2 of sbl crash dump (Aarch64)

;****************************************************************************

; Note: Script assumes that the SBL elf is already loaded

entry &crash_dumps_path

&crash_dump_cookie=0x45525220

&default_dump_dir="C:\ProgramData\Qualcomm\QPST\Sahara\"
&dump_type="1"
&bin_filename_struct=""
&bin_filename_bootddr=""
&bin_filename_bootimem=""
&bin_filename_sharedimem=""

WINPOS 0% 50% 68% 50% 0. 0. W001
Area.create MAIN
Area.view MAIN
Area.select MAIN

print "---------------------------------------------------------------"
print "---------------SBL boot crash dump loader script---------------"
print "---------------------------------------------------------------"

;
if (!symbol.exist(boot_crash_dump_data))
(
  print "Script could not find symbols."
  print "Please load elf XBLLoader.dll, or use boot_debug.cmm."
  print "exiting"
  enddo false()
)

print
print

if os.dir("&default_dump_dir")
(
  ChDir "&default_dump_dir"
)
print "Select type of dumps to be loaded(1 for XBL_SC full dumps, 2 for XBL_SC decrypted minidumps):"
enter &dump_type
if "&dump_type"=="1"
(
&bin_filename_struct="CD_STRCT.BIN"
&bin_filename_bootddr="CD_BTDDR.BIN"
&bin_filename_bootimem="CD_BTIMM.BIN"
&bin_filename_sharedimem="CD_SHIMM.BIN"
)
if "&dump_type"=="2"
(
&bin_filename_struct="md_xbl_strct.BIN"
&bin_filename_bootddr="md_xbl_ddr.BIN"
&bin_filename_bootimem="md_xbl_imem.BIN"
&bin_filename_sharedimem="md_xbl_shrd_imm.BIN"
)
print "Select Port_COM folder containing your crash dump"
dialog.dir *
entry &crash_dumps_path
if "&crash_dumps_path"==""
(
  print "Failed to select file. Exiting..."
  &crash_dumps_path
)
print
print


; start simulator
sys.up

; load boot crash data into crash_dump_addr
d.load.binary "&crash_dumps_path\&bin_filename_struct" boot_crash_dump_data /noclear

; check for the boot_crash_dump_data.boot_crash_dump_arm_data variable which will be used to 
; load the dumps and the registers
if (v.value(boot_crash_dump_data.boot_crash_dump_arm_data.crash_dump_cookie)!=&crash_dump_cookie)
(
  print "crash_dump_cookie not found in "&crash_dumps_path\&bin_filename_struct"."
  print "this binary does not contain a crash dump." 
  enddo false()
)

; currently supports version 2 of the structure.
; reference for this structure is found in the following place:
;   boot_error_handler.h    boot_crash_dump_type
if (v.value(boot_crash_dump_data.boot_crash_dump_arm_data.version)==2)
(
  print "found version 2 of boot crash dump data struct."
  print

  ; switch to SVC mode and load SVC registers
  r.s CPSR 0xD3
  r.s r0 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[0]")
  r.s r1 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[1]")
  r.s r2 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[2]")
  r.s r3 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[3]")
  r.s r4 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[4]")
  r.s r5 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[5]")
  r.s r6 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[6]")
  r.s r7 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[7]")
  r.s r8 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[8]")
  r.s r9 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[9]")
  r.s r10 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[10]")
  r.s r11 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[11]")
  r.s r12 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[12]")
  r.s r13_svc v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[13]")
  r.s r14_svc v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[14]")
  r.s spsr_svc v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[15]")
  r.s pc v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[16]")

  ; switch to SYS mode and load SYS registers
  r.s CPSR 0xDF
  r.s r13 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[18]")
  r.s r14 v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[19]")

  ; switch to IRQ mode and load IRQ registers
  r.s CPSR 0xD2
  r.s r13_irq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[20]")
  r.s r14_irq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[21]")
  r.s spsr_irq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[22]")

  ; switch to ABT mode and load ABT registers
  r.s CPSR 0xD7
  r.s r13_abt v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[23]")
  r.s r14_abt v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[24]")
  r.s spsr_abt v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[25]")

  ; switch to UND mode and load UND registers
  r.s CPSR 0xDB
  r.s r13_und v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[26]")
  r.s r14_und v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[27]")
  r.s spsr_und v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[28]")

  ; switch to FIQ mode and load FIQ registers
  r.s CPSR 0xD1
  r.s r8_fiq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[29]")
  r.s r9_fiq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[30]")
  r.s r10_fiq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[31]")
  r.s r11_fiq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[32]")
  r.s r12_fiq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[33]")
  r.s r13_fiq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[34]")
  r.s r14_fiq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[35]")
  r.s spsr_fiq v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[36]")

  ; load saved CPSR value which will switch to mode proc was in when error ocurred
  r.s cpsr v.value("boot_crash_dump_data.boot_crash_dump_arm_data.regs[17]")


  ; set the values from boot_crash_struct
  &sbl_ddr_addr=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_ddr_addr)
  &sbl_ddr_size=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_ddr_size)
  &sbl_ddr_dump_addr=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_ddr_dump_addr)
  &sbl_boot_imem_addr=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_boot_imem_addr)
  &sbl_boot_imem_size=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_boot_imem_size)
  &sbl_boot_imem_dump_addr=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_boot_imem_dump_addr)
  &sbl_shared_imem_addr=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_shared_imem_addr)
  &sbl_shared_imem_size=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_shared_imem_size)
  &sbl_shared_imem_dump_addr=v.value(boot_crash_dump_data.boot_crash_dump_arm_data.sbl_shared_imem_dump_addr)

  ; put dump data into proper locations according to struct
  d.load.binary "&crash_dumps_path\&bin_filename_bootddr" &sbl_ddr_addr /noclear
  d.load.binary "&crash_dumps_path\&bin_filename_bootimem" &sbl_boot_imem_addr /noclear
  d.load.binary "&crash_dumps_path\&bin_filename_sharedimem" &sbl_shared_imem_addr /noclear
  
  ;Print boot logs
  do save_xbl_log.cmm

  if (symbol.exist(backup_stack_buf))
  (
    &stack_overlay_addr = v.value(boot_crash_dump_data.boot_crash_dump_arm_data.regs[13])
    data.copy backup_stack_buf++var.sizeof(backup_stack_buf) &stack_overlay_addr
  )
  
  print
  print "SBL crash dumps loaded."
  gosub SetupDebugWindows yes
  
  ; unroll the stack past boot_error_handler
  ;frame.up
  ;frame.up
  
  enddo true()
)
else 
(
  print "Found incompatible boot_crash_dump_type version"
  enddo false()
)

;****************************************************************************
; Setup and display the windows to debug the processor
;****************************************************************************
SetupDebugWindows:
  
  TOOLBAR ON
  STATUSBAR ON

  WINPOS 0.0 0.0 68% 65% 12. 1. W000 Normal "DATA.LIST"
  DATA.list
 
  WINPOS 68% 0. 32% 50% 0. 0. W002 Normal "REGISTERS"
  register /spotlight
 
  setup.var %open.on %hex %symbol

  WINPOS  68% 50% 32% 48% 0. 0. W003 Normal "CALL STACK"
  Var.Frame
  
  return ; SetupDebugWindows
