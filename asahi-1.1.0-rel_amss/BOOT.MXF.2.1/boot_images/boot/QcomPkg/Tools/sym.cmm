;============================================================================
;  Name:
;    sym.cmm
;
;  Description:
;     Loads UEFI symbols, after halting target
;
; Copyright (c) 2015-2017, 2019, 2020, 2021 Qualcomm Technologies Incorporated.
; All Rights Reserved.
; Qualcomm Technologies Confidential and Proprietary
;
;----------------------------------------------------------------------------
;============================================================================
;
;                        EDIT HISTORY FOR MODULE
;
;
;
; when         who     what, where, why
; ----------   ---     ----------------------------------------------------------
; 2020-11-09   ka      Added argument InfoBlkPtrOffset
; 2017-09-12   vk      Remove PATH
; 2015-05-09   vk      Use physical address
; 2016-02-18   bh      Update info block offset
; 2015-10-16   bh      Fix incremental driver vs. full symbol loading
; 2015-10-15   bh      Initial revision
;============================================================================;

local &SecAddr
local &CwDir
local &RamCmd
local &ModName
local &ModuleBkpt
local &tfile1
local &CmdIncrOffset

global &InfoBlkAddr
global &AppObjPath
global &ModuleSrcRoot
global &ModuleObjRoot
global &UefiRootDirName
global &AppSrcDirName
global &AppObjDirName

;
;  Arguments:
;  UefiBase : UEFI FD address
;  RunOption : What mode script is running in
;              0 = Load all symbols without debug in progress
;              1 = Load symbols incrementally only additional images loaded after last load
;              2 = Load incremental symbols and run till current image entry point
; 
; InfoBlkPtrOffset : UEFI Info Block offset pointer
;

ENTRY &UefiBase &RunOption &InfoBlkPtrOffset
  &CwDir=os.ppd()

  do &CwDir/InitOffsets.cmm

  if ("&InfoBlkPtrOffset"=="")
  (
    &InfoBlkPtrOffset=0x00601000
  )
  
  gosub VerifyInfoBlk &UefiBase &InfoBlkPtrOffset

  &TempFile=OS.TMPFILE()
  &TempFile="&TempFile.cmm"

  &CmdSize=data.long(D:&InfoBlkAddr+&IBlkTotalCmdSize)
  &CmdAddr=data.long(D:&InfoBlkAddr+&IBlkSymbolCmdString)
  &CmdEnd=&CmdAddr+&CmdSize-1

  if (&RunOption!=0)
  (
    &CmdIncrOffset=data.long(D:&InfoBlkAddr+&IBlkCmdStartOffset)
    &CmdIncrOffset=&CmdAddr+&CmdIncrOffset
    data.save.binary &TempFile DC:&CmdIncrOffset--&CmdEnd
    data.set &InfoBlkAddr+&IBlkCmdStartOffset %LONG &CmdSize
  )
  else
  (
    data.save.binary &TempFile DC:&CmdAddr--&CmdEnd
  )

  cd &CwDir/../../../

  &ModuleSrcRoot="&UefiRootDirName"
  &ModuleObjRoot="&UefiRootDirName"
  do &TempFile

  if ("&AppObjPath"!="")
  (
    cd &AppObjPath

    &ModuleSrcRoot="&AppSrcDirName"
    &ModuleObjRoot="&AppObjDirName"
    do &TempFile

    cd &CwDir/../../
  )

  rm &TempFile

  if (&RunOption==2)
  (
    &ModName=data.string(D:&InfoBlkAddr+&IBlkModuleName)
    &ModuleBkpt="\\&ModName\AutoGen\ProcessModuleEntryPointList"
    if (!sYmbol.EXIST(&ModuleBkpt))
    (  
      local &temp
      &temp="&ModName"+"_"+"AutoGen"
      &ModuleBkpt="\\&ModName\&temp\ProcessModuleEntryPointList"
    )
    g &ModuleBkpt
    wait !run()
    b.enable BreakPointFunction
  )

enddo


VerifyInfoBlk:
  ENTRY &ParamUefiBaseAddr &InfoBlkPtrOffset

  local &InfFound

  if (os.file("&CwDir/oem_infblk.cmm"))
  (
    do &CwDir/oem_infblk.cmm
  )

  &InfoBlkAddr=&ParamUefiBaseAddr+&InfoBlkPtrOffset

  ;Read signature and verify
  &Sig=data.long(D:&InfoBlkAddr)

  ;Check signature before dereference
  if (&Sig==0x6B6C4249)
    &InfFound=1
  else
    &InfFound=0

  if (&InfFound==0)
  (
    print %ERROR "UefiInfoBlk not found"
    end
  )
  else
    return
