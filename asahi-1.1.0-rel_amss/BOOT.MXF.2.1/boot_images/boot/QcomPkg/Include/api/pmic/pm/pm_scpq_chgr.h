#ifndef __PM_SCPQ_CHGR_H__
#define __PM_SCPQ_CHGR_H__

/*! \file
 *  \n
 *  \brief  pm_scpq_chgr.h PMIC-SCPQ MODULE RELATED DECLARATION
 *  \details  This header file contains functions and variable declarations
 *  to support Qualcomm PMIC SCPQ (Switch-Mode Battery Charger) module. The
 *  Switched-Mode Battery Charger (SCPQ) module includes a buck regulated
 *  battery charger with integrated switches. The SCPQ module, along with the
 *  Over Voltage Proection (OVP) module will majorly be used by charger
 *  appliation for charging Li-Ion batteries with high current (up to 2A).
 *  \n &copy; Copyright 2020-2022 QUALCOMM Technologies Incorporated, All Rights Reserved.
 */

/*===========================================================================

                        EDIT HISTORY FOR MODULE


when        who    what, where, why
--------    ---    ----------------------------------------------------------
12/02/19    zzx    Initial revision
========================================================================== */

/*===========================================================================

                        INCLUDE FILES

===========================================================================*/
#include "com_dtypes.h"
#include "pm_err_flags.h"

/*===========================================================================

                        TYPE DEFINITIONS

===========================================================================*/

typedef enum
{
  PM_SCPQ_CHGR_PRE_CHARGE_CURRENT,   //pre_charge current
  PM_SCPQ_CHGR_FAST_CHARGE_CURRENT,  //fast charge current
  PM_SCPQ_CHGR_TERMINATION_CURRENT,  //termination current
  PM_SCPQ_CHGR_CURRENT_TYPE_INVALID, //invalid
}pm_scpq_chgr_current_type;

typedef enum
{
  PM_SCPQ_BATT_CHGR_STATUS_INHIBIT,
  PM_SCPQ_BATT_CHGR_STATUS_TRICKLE,
  PM_SCPQ_BATT_CHGR_STATUS_PRECHARGE,
  PM_SCPQ_BATT_CHGR_STATUS_FULLON,
  PM_SCPQ_BATT_CHGR_STATUS_TAPER,
  PM_SCPQ_BATT_CHGR_STATUS_TERMINATION,
  PM_SCPQ_BATT_CHGR_STATUS_PAUSE,
  PM_SCPQ_BATT_CHGR_STATUS_DISABLED,
  PM_SCPQ_BATT_CHGR_STATUS_INVALID,
  PM_SCPQ_BATT_CHGR_STATUS_COUNT
}pm_scpq_battery_charger_status;


typedef enum
{
  PM_SCPQ_VPH_TRACK_SEL_0_PCT,
  PM_SCPQ_VPH_TRACK_SEL_0P5_PCT,
  PM_SCPQ_VPH_TRACK_SEL_1_PCT,
  PM_SCPQ_VPH_TRACK_SEL_2_PCT,
  PM_SCPQ_VPH_TRACK_SEL_3_PCT,
  PM_SCPQ_VPH_TRACK_SEL_7_PCT,
  PM_SCPQ_VPH_TRACK_SEL_8_PCT,
  PM_SCPQ_VPH_TRACK_SEL_9_PCT,
  PM_SCPQ_VPH_TRACK_SEL_INVALID,
}pm_scpq_chgr_vph_track_sel_type;

typedef enum
{
  PM_SCPQ_CHGR_WDOG_BB_STATUS_BARK,
  PM_SCPQ_CHGR_WDOG_BB_STATUS_BITE,
  PM_SCPQ_CHGR_WDOG_BB_STATUS_INVALID,
} pm_scpq_chgr_wdog_bb_status_type;

typedef struct
{
  pm_scpq_battery_charger_status battery_charger_status;
  boolean charger_error_status_ibat_oc; // charger error int caused by Battery Over-Current
  boolean charger_error_status_bat_ov; // charger error int caused by Battery Over-Voltage
  boolean charger_error_status_sft_expire;  //safety timer expired
  boolean valid_input_power_source;
}pm_scpq_chgr_charger_status;

typedef struct
{
  boolean enable_chg_sensors;
  boolean enable_trickle;
  boolean enable_pre_charging;
  boolean enable_fullon_mode;
  boolean charging_enable;
  boolean disable_charging;
}pm_scpq_chgr_chg_en_status;

typedef struct
{
  boolean vbatt_lt_2v;
  boolean vbatt_gt_full_on;   //0x1: VBATT >= VSYS_MIN(fast charge threshold)
  boolean vbatt_gtet_inhibit;
  boolean vbatt_ltet_recharge;
  boolean taper_region;       //0x1: charger is in taper region(CV)
  boolean vbatt_drop_in_fv;   //0x1: VBATT dropped below float voltage during taper charging
  boolean gf_batt_ov;         //glitch filtered or not of BATT_OV, 0x0: VBATT_BELOW_OV, 0x1: VBATT_ABOVE_OV
}pm_scpq_chgr_vbat_status;

typedef struct
{
  boolean pre_fullon;   //<1> 0x1: VBATT > VSYS_MIN(fast charge threshold)
  boolean pre_inhibit;  //<3> 0x1: VBATT > INHIBIT_THRESHOLD
  boolean taper;        //<5> Error amplifier output generated by comparing VFLT reference with actual battery voltage.
  boolean pre_ovrv;     //<7> 0x1: VBATT > VBAT_OV threshold(VFLT + 40mV)
}pm_scpq_chgr_vbat_status2;

typedef struct
{
  boolean zero_charge_current;        //<0> 0x1: ZERO_CHARGE_CURRENT 0x0: NONE_ZERO
  boolean force_zero_charge_current;  //<1> 0x1: when high, charge current is ramped down to zero
  boolean pre_term;                   //<2> 0x1: charge current < termination current
  boolean icl_incr_req_for_prechg;    //<7> ICL value increment during precharge
}pm_scpq_chgr_ibat_status;

typedef struct
{
  pm_scpq_chgr_charger_status      charger_status;
  pm_scpq_chgr_chg_en_status       chg_en_status;
  pm_scpq_chgr_vbat_status         vbat_status;
  pm_scpq_chgr_vbat_status2        vbat_status2;
  pm_scpq_chgr_ibat_status         ibat_status;
  uint8                            vflt_status;  //float_voltage
  uint8                            ichg_status;  //charge current reference
  pm_scpq_chgr_wdog_bb_status_type bb_status;                       
}pm_scpq_chgr_status_type;

typedef enum {
  PM_SCPQ_CHGR_BARK,
  PM_SCPQ_CHGR_BITE,
  PM_SCPQ_CHGR_BARK_BITE_INVALID,
}pm_scpq_chgr_wdog_status;

typedef struct {
  boolean wdog_timer_en;                  //Watchdog time enable/disable, bit0
  boolean wdog_timer_en_on_plugin;        //All three watchdog timers enable/disable during plugin, bit1
  boolean bark_wdog_int_en;               //BARK watchdog timer expire interrupt enable/disable, bit4
  boolean bite_wdog_int_en;               //BITE watchdog timre expire interrupt enable/disable, bit5
  boolean bite_wdog_disable_charging_cfg; //Controls charging enable/disable after Bite wd timer expires, bit7 
}pm_scpq_chgr_wdog_cfg_type;

/*===========================================================================

                        SCPQ DRIVER FUNCTION PROTOTYPES

===========================================================================*/
 /**
 * @brief This function sets the various type of current
 *
 * @details
 *  This function sets the various type of current
 *
 * @param[in] pmic_index:           The pmic_index of charger module.
 * @param[in] charge_current_type:  Refer #pm_scpq_chgr_current_type for details.
 * @param[in] current_in_ma:        Current value in the unit of mA.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_chgr_set_charge_current(uint32 pmic_index, pm_scpq_chgr_current_type charge_current_type, uint32 current_in_ma);

 /**
 * @brief This function gets the various type of current config
 *
 * @details
 *  This function gets the various type of current
 *
 * @param[in] pmic_index:           The pmic_index of charger module.
 * @param[in] charge_current_type:  Refer #pm_scpq_chgr_current_type for details.
 * @param[in] current_in_ma:       Current value in the unit of mA of 1S battery, in the case of 2S battery, current value is half of 1S battery.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_chgr_get_charge_current_cfg(uint32 pmic_index, pm_scpq_chgr_current_type charge_current_type, uint32* current_in_ma);

/**
 * @brief This function enable/disable charging function
 *
 * @details
 *  This function sets the various type of charge cmd registers
 *
 * @param[in] pmic_index:  The pmic_index of charger module.
 * @param[in] charge_current_type:  Refer #pm_scpq_chgr_current_type for details.
 * @param[out] current_in_ma:       Current value in the unit of mA of 1S battery, in the case of 2S battery, current value is half of 1S battery.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_chgr_enable_charging(uint32 pmic_index, boolean enable);

/**
 * @brief This function returns the various charger status type
 *
 * @details
 *  This function returns the various charger status type
 *
 * @param[in] pmic_index:    The pmic_index of charger module.
 * @param[out] chgr_status:  Refer #pm_scpq_chgr_status_type for details.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_chgr_get_chgr_status(uint32 pmic_index, pm_scpq_chgr_status_type *chgr_status);

/**
 * @brief This function configures the floating voltage
 *
 * @details
 * This API configures the floating voltage. Valid range is 3600mV to 4790 mv
 *
 * @param[in] pmic_index:     The pmic_index of charger module.
 * @param[in] float_volt_mv:  Valid range is 3600mV to 4790 mv.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_chgr_set_float_volt(uint32 pmic_index, uint32 float_volt_mv);

/**
 * @brief This function gets the floating voltage config
 *
 * @details
 * This API gets the floating voltage. Valid range is 3600mV to 4790 mv
 *
 * @param[in] pmic_index:     The pmic_index of charger module.
 * @param[out] float_volt_mv: Valid range is 3600mV to 4790 mv.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_chgr_get_float_volt_cfg(uint32 pmic_index, uint32 *float_volt_mv);

/**
 * @brief This function provides SCPQ charger PMIC info.
 *
 * @details
 *  This function provides SCPQ charger PMIC info.
 *
 * @param[out] pmic_index:     The pmic_index of charger module.
 * @param[out] slave_id:       On what SlaveID for given PMIC, SCPQ charger resides.
 * @param[out] charger_count:  Charger count.
 * @param[in]  max_charger:    Max charger count.
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available.
 *          PM_ERR_FLAG_INVALID_PARAMETER     = Invalid parameters.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 */
pm_err_flag_type
pm_scpq_chgr_get_scpq_pmic_info(uint32 *pmic_index, uint32 *slave_id, uint32* charger_count, uint32 max_charger);

/**
* @brief This function configure vsysmin value
*
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[in] vsysmin_mv:   Vsysmin voltage in mV.
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type
pm_scpq_chgr_configure_vsysmin(uint32 pmic_index, uint32 vsysmin_mv);

/**
* @brief This function gets the configure of vsysmin value
*
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[out] vsysmin_mv:  Vsysmin voltage in mV.
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type
pm_scpq_chgr_get_vsysmin_cfg(uint32 pmic_index, uint32* vsysmin_mv);

/**
* @brief This function select VPH tracking threshold during Pre-Charge
*
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[in] track_sel:    VPH tracking threshold, see #pm_scpq_chgr_vph_track_sel_type for details.
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type
pm_scpq_chgr_vph_track_threshold_sel(uint32 pmic_index, pm_scpq_chgr_vph_track_sel_type track_sel);

/**
* @brief This function Enable/disable for VPH pre-charge algorithm
*
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[in] enable:       0 : Disable algorithm to regulate pre-charge current based on VPH threshold
*                          1 : Enable algorithm to regulate pre-charge current based on VPH threshold
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type
pm_scpq_chgr_vph_prechg_alg_en(uint32 pmic_index, boolean enable);


/**
* @brief This function get the status of PMIC watch dog
*
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[out] chgr_wdog_sts: When bark/bite watchdog interrupt trips, 
*                            this status bit can be used to determine which of the two wdog timer expired. 
*            
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type 
pm_scpq_chgr_get_chgr_wdog_status(uint32 pmic_index, pm_scpq_chgr_wdog_status *chgr_wdog_sts);

/**
 * @brief Writing to this register will pet (reset) BARK and BITE watchdog timers 
 * 
 * @details
 *  Writing to this register will pet (reset) BARK and BITE watchdog timers 
 * 
 * @param[in] pmic_index:  The pmic_index of charger module.
 *
 * @return  pm_err_flag_type 
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type 
pm_scpq_chgr_bark_bite_wdog_pet(uint32 pmic_index);


/**
 * @brief This function configures the charger watchdog
 * 
 * @details
 *  This function configures the charger watchdog
 * 
 * @param[in] pmic_index:   The pmic_index of charger module.
 * @param[in] chgr_wd_cfg:  Refer #pm_scpq_chgr_wdog_cfg_type for details.
 *                                
 *
 * @return  pm_err_flag_type 
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type 
pm_scpq_chgr_config_wdog(uint32 pmic_index, pm_scpq_chgr_wdog_cfg_type chgr_wd_cfg);


/**
 * @brief This function configures the timeout selection of bark for charger watchdog
 * 
 * @param[in] pmic_index: The pmic_index of charger module.
 * @param[in] timeout_ms: Timeout value in the unit of ms.
 *                                
 *
 * @return  pm_err_flag_type 
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type 
pm_scpq_chgr_set_wd_bark_timeout(uint32 pmic_index, uint32 timeout_ms);


/**
 * @brief This function configures the timeout selection of bite for charger watchdog
 * 
 * @param[in] pmic_index: The pmic_index of charger module.
 * @param[in] timeout_ms: Timeout value in the unit of ms.
 *                                
 *
 * @return  pm_err_flag_type 
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type 
pm_scpq_chgr_set_wd_bite_timeout(uint32 pmic_index, uint32 timeout_ms);


/**
 * @brief This function configures the timeout selection of snarl for charger watchdog
 * 
 * @param[in] pmic_index: The pmic_index of charger module.
 * @param[in] timeout_ms: Timeout value in the unit of ms.
 *                                
 *
 * @return  pm_err_flag_type 
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type 
pm_scpq_chgr_set_wd_snarl_timeout(uint32 pmic_index, uint32 timeout_ms);



/**
 * @brief This function returns the charger watchdog config
 * 
 * @details
 *  This function returns the charger watchdog config
 * 
 * @param[in] pmic_index:   The pmic_index of charger module.
 * @param[in] chgr_wd_cfg:  Refer #pm_scpq_chgr_wdog_cfg_type for details.
 *                                
 *
 * @return  pm_err_flag_type 
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_chgr_get_config_wdog(uint32 pmic_index, pm_scpq_chgr_wdog_cfg_type *chgr_wd_cfg);

#endif /*_SCPQ_CHGR_H__ */

