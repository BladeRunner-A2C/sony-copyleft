#ifndef __PM_SCPQ_HS_CHGR_H__
#define __PM_SCPQ_HS_CHGR_H__

/*! \file
 *  \n
 *  \brief  pm_scpq_hs_chgr.h PMIC-SCPQ HS MODULE RELATED DECLARATION
 *  \details  This header file contains functions and variable declarations
 *  to support Qualcomm PMIC SCPQ (Switch-Mode Battery Charger) module. The
 *  Switched-Mode Battery Charger (SCPQ) module includes a buck regulated
 *  battery charger with integrated switches. The SCPQ module, along with the
 *  Over Voltage Proection (OVP) module will majorly be used by charger
 *  appliation for charging Li-Ion batteries with high current (up to 2A).
 *  Copyright (c) 2022,2023 Qualcomm Technologies, Inc. All rights reserved.
 *  Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

/*===========================================================================

                        EDIT HISTORY FOR MODULE


when        who    what, where, why
--------    ---    ----------------------------------------------------------
01/19/23    rs    Initial revision
========================================================================== */

/*===========================================================================

                        INCLUDE FILES

===========================================================================*/
#include "com_dtypes.h"
#include "pm_err_flags.h"

/*===========================================================================

                        TYPE DEFINITIONS

===========================================================================*/

typedef enum
{
  PM_SCPQ_HS_CHGR_PRE_CHARGE_CURRENT,   //pre_charge current
  PM_SCPQ_HS_CHGR_FAST_CHARGE_CURRENT,  //fast charge current
  PM_SCPQ_HS_CHGR_TERMINATION_CURRENT,  //termination current
  PM_SCPQ_HS_CHGR_CURRENT_TYPE_INVALID, //invalid
}pm_scpq_hs_chgr_current_type;

typedef enum
{
  PM_SCPQ_HS_BATT_CHGR_STATUS_INHIBIT,
  PM_SCPQ_HS_BATT_CHGR_STATUS_TRICKLE,
  PM_SCPQ_HS_BATT_CHGR_STATUS_PRECHARGE,
  PM_SCPQ_HS_BATT_CHGR_STATUS_FULLON,
  PM_SCPQ_HS_BATT_CHGR_STATUS_TAPER,
  PM_SCPQ_HS_BATT_CHGR_STATUS_TERMINATION,
  PM_SCPQ_HS_BATT_CHGR_STATUS_PAUSE,
  PM_SCPQ_HS_BATT_CHGR_STATUS_DISABLED,
  PM_SCPQ_HS_BATT_CHGR_STATUS_INVALID,
  PM_SCPQ_HS_BATT_CHGR_STATUS_COUNT
}pm_scpq_hs_battery_charger_status;


typedef enum
{
  PM_SCPQ_HS_VPH_TRACK_SEL_0_PCT,
  PM_SCPQ_HS_VPH_TRACK_SEL_0P5_PCT,
  PM_SCPQ_HS_VPH_TRACK_SEL_1_PCT,
  PM_SCPQ_HS_VPH_TRACK_SEL_2_PCT,
  PM_SCPQ_HS_VPH_TRACK_SEL_3_PCT,
  PM_SCPQ_HS_VPH_TRACK_SEL_7_PCT,
  PM_SCPQ_HS_VPH_TRACK_SEL_8_PCT,
  PM_SCPQ_HS_VPH_TRACK_SEL_9_PCT,
  PM_SCPQ_HS_VPH_TRACK_SEL_INVALID,
}pm_scpq_hs_chgr_vph_track_sel_type;

typedef struct
{
  pm_scpq_hs_battery_charger_status battery_charger_status;
  boolean charger_error_status_ibat_oc; // charger error int caused by Battery Over-Current
  boolean charger_error_status_bat_ov; // charger error int caused by Battery Over-Voltage
  boolean charger_error_status_sft_expire;  //safety timer expired
  boolean valid_input_power_source;
}pm_scpq_hs_chgr_charger_status;

typedef struct
{
  boolean enable_chg_sensors;
  boolean enable_trickle;
  boolean enable_pre_charging;
  boolean enable_fullon_mode;
  boolean charging_enable;
  boolean disable_charging;
}pm_scpq_hs_chgr_chg_en_status;

typedef struct
{
  boolean vbatt_lt_2v;
  boolean vbatt_gt_full_on;   //0x1: VBATT >= VSYS_MIN(fast charge threshold)
  boolean vbatt_gtet_inhibit;
  boolean vbatt_ltet_recharge;
  boolean taper_region;       //0x1: charger is in taper region(CV)
  boolean vbatt_drop_in_fv;   //0x1: VBATT dropped below float voltage during taper charging
  boolean gf_batt_ov;         //glitch filtered or not of BATT_OV, 0x0: VBATT_BELOW_OV, 0x1: VBATT_ABOVE_OV
}pm_scpq_hs_chgr_vbat_status;

typedef struct
{
  boolean pre_fullon;   //<1> 0x1: VBATT > VSYS_MIN(fast charge threshold)
  boolean pre_inhibit;  //<3> 0x1: VBATT > INHIBIT_THRESHOLD
  boolean taper;        //<5> Error amplifier output generated by comparing VFLT reference with actual battery voltage.
  boolean pre_ovrv;     //<7> 0x1: VBATT > VBAT_OV threshold(VFLT + 40mV)
}pm_scpq_hs_chgr_vbat_status2;

typedef struct
{
  boolean zero_charge_current;        //<0> 0x1: ZERO_CHARGE_CURRENT 0x0: NONE_ZERO
  boolean force_zero_charge_current;  //<1> 0x1: when high, charge current is ramped down to zero
  boolean pre_term;                   //<2> 0x1: charge current < termination current
  boolean icl_incr_req_for_prechg;    //<7> ICL value increment during precharge
}pm_scpq_hs_chgr_ibat_status;

typedef struct
{
  pm_scpq_hs_chgr_charger_status      charger_status;
  pm_scpq_hs_chgr_chg_en_status       chg_en_status;
  pm_scpq_hs_chgr_vbat_status         vbat_status;
  pm_scpq_hs_chgr_vbat_status2        vbat_status2;
  pm_scpq_hs_chgr_ibat_status         ibat_status;
  uint8                            vflt_status;  //float_voltage
  uint8                            ichg_status;  //charge current reference
}pm_scpq_hs_chgr_status_type;

/*===========================================================================

                        SCPQ HS DRIVER FUNCTION PROTOTYPES

===========================================================================*/
 /**
 * @brief This function sets the various type of current
 *
 * @details
 *  This function sets the various type of current
 *
 * @param[in] bus_id: SPMI Bus id
 * @param[in] pmic_index:           The pmic_index of charger module.
 * @param[in] charge_current_type:  Refer #pm_scpq_hs_chgr_current_type for details.
 * @param[in] current_in_ma:        Current value in the unit of mA.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_hs_chgr_set_charge_current(uint32 bus_id, uint32 pmic_index, pm_scpq_hs_chgr_current_type charge_current_type, uint32 current_in_ma);

 /**
 * @brief This function gets the various type of current config
 *
 * @details
 *  This function gets the various type of current
 *
 * @param[in] bus_id: SPMI Bus id
 * @param[in] pmic_index:           The pmic_index of charger module.
 * @param[in] charge_current_type:  Refer #pm_scpq_hs_chgr_current_type for details.
 * @param[in] current_in_ma:       Current value in the unit of mA of 1S battery, in the case of 2S battery, current value is half of 1S battery.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_hs_chgr_get_charge_current_cfg(uint32 bus_id, uint32 pmic_index, pm_scpq_hs_chgr_current_type charge_current_type, uint32* current_in_ma);

/**
 * @brief This function enable/disable charging function
 *
 * @details
 *  This function sets the various type of charge cmd registers
 *
 * @param[in] bus_id: SPMI Bus id
 * @param[in] pmic_index:  The pmic_index of charger module.
 * @param[in] charge_current_type:  Refer #pm_scpq_hs_chgr_current_type for details.
 * @param[out] current_in_ma:       Current value in the unit of mA of 1S battery, in the case of 2S battery, current value is half of 1S battery.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_hs_chgr_enable_charging(uint32 bus_id, uint32 pmic_index, boolean enable);

/**
 * @brief This function returns the various charger status type
 *
 * @details
 *  This function returns the various charger status type
 *
 * @param[in] bus_id: SPMI Bus id
 * @param[in] pmic_index:    The pmic_index of charger module.
 * @param[out] chgr_status:  Refer #pm_scpq_hs_chgr_status_type for details.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_hs_chgr_get_chgr_status(uint32 bus_id, uint32 pmic_index, pm_scpq_hs_chgr_status_type *chgr_status);

/**
 * @brief This function configures the floating voltage
 *
 * @details
 * This API configures the floating voltage. Valid range is 3600mV to 4790 mv
 *
 * @param[in] bus_id: SPMI Bus id
 * @param[in] pmic_index:     The pmic_index of charger module.
 * @param[in] float_volt_mv:  Valid range is 3600mV to 4790 mv.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_hs_chgr_set_float_volt(uint32 bus_id, uint32 pmic_index, uint32 float_volt_mv);

/**
 * @brief This function gets the floating voltage config
 *
 * @details
 * This API gets the floating voltage. Valid range is 3600mV to 4790 mv
 *
 * @param[in] bus_id: SPMI Bus id
 * @param[in] pmic_index:     The pmic_index of charger module.
 * @param[out] float_volt_mv: Valid range is 3600mV to 4790 mv.
 *
 *
 * @return  pm_err_flag_type
 *          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
 *          version of the PMIC.
 *          PM_ERR_FLAG_SUCCESS               = SUCCESS.
 *
 */
pm_err_flag_type
pm_scpq_hs_chgr_get_float_volt_cfg(uint32 bus_id, uint32 pmic_index, uint32 *float_volt_mv);


/**
* @brief This function configure vsysmin value
*
* @param[in] bus_id: SPMI Bus id
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[in] vsysmin_mv:   Vsysmin voltage in mV.
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type
pm_scpq_hs_chgr_configure_vsysmin(uint32 bus_id, uint32 pmic_index, uint32 vsysmin_mv);

/**
* @brief This function gets the configure of vsysmin value
*
* @param[in] bus_id: SPMI Bus id
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[out] vsysmin_mv:  Vsysmin voltage in mV.
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type
pm_scpq_hs_chgr_get_vsysmin_cfg(uint32 bus_id, uint32 pmic_index, uint32* vsysmin_mv);

/**
* @brief This function select VPH tracking threshold during Pre-Charge
*
* @param[in] bus_id: SPMI Bus id
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[in] track_sel:    VPH tracking threshold, see #pm_scpq_hs_chgr_vph_track_sel_type for details.
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type
pm_scpq_hs_chgr_vph_track_threshold_sel(uint32 bus_id, uint32 pmic_index, pm_scpq_hs_chgr_vph_track_sel_type track_sel);

/**
* @brief This function Enable/disable for VPH pre-charge algorithm
*
* @param[in] bus_id: SPMI Bus id
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[in] enable:       0 : Disable algorithm to regulate pre-charge current based on VPH threshold
*                          1 : Enable algorithm to regulate pre-charge current based on VPH threshold
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type
pm_scpq_hs_chgr_vph_prechg_alg_en(uint32 bus_id, uint32 pmic_index, boolean enable);


/**
* @brief function to get charger count
*
* @param[in] bus_id: SPMI Bus id
* @param[in] pmic_device:  The pmic_index of charger module.
* @param[in] charger_count:charger count
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/
pm_err_flag_type 
pm_scpq_hs_chgr_get_scpq_hs_pmic_info(uint32 bus_id,uint32 *pmic_index, uint32 *slave_id, uint32* charger_count, uint32 max_charger);

/**
* @brief function to get wls irq count, not supported for sculpin
*
* @param[in] bus_id: SPMI Bus id
* @param[in] pmic_device:  The pmic_index of charger module.
*
* @return  pm_err_flag_type
*          PM_ERR_FLAG_FEATURE_NOT_SUPPORTED = Feature not available on this
*          version of the PMIC.
*          PM_ERR_FLAG_SUCCESS               = SUCCESS.
*/

pm_err_flag_type pm_scpq_hs_wls_irq_status(uint32 bus_id, uint32 pmic_index);

#endif /*_SCPQ_HS_CHGR_H__ */

