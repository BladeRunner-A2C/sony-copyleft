Introduction
============

The XCS locking solution allows business partners to install
additional signing keys and/or certificates into a mobile device, to
be used for authenticating selected parts of the device software. The
current implementation requires a server-generated data structure to
be written into the device. This data structure contains an ID which
is unique for the device at hand; an ID which can be used by Sony to
uniquely identify, and track, a device. Hence, from a partner
perspective, it is desirable to hide this ID from Sony, or any other
third party.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in [RFC2119]_.

Definitions
===========

Mobile Device
   A Mobile Device is the end user equipment that contains the custom
   software. For example, this can be a mobile phone, a tablet, or any
   other consumer device.

Key Blob
   The data structure that contains the keys used for authenticating
   software components.

Device Binding
   An identifier that is unique to a specific Mobile Device. For
   example, this can be the IMEI, a hardware serial number or an
   identifier derived from hardware-bound cryptographic keys.
   Device binding support a list of identifiers to handle isolated
   subsystems, e.g. a separate modem.

Bootloader
   The software component that loads, authenticates and starts the
   system OS kernel.

XCS Partner
   A business partner developing custom software under the XCS program.

Locking
   The act of inserting a new authentication key into a Mobile Device.

User
   The person who performs the Locking sequence.

Server
   A secure host which holds the secret keys used to digitally sign
   data originating from Sony.

.. _requirements:

Requirements
============

These basic requirements serve as guiding principles for the
implementation described in the next section of this document. They
also serve to aid the understanding of why certain choices are made.

#. The Device Binding MUST be hidden from everyone
   except the XCS Partner. It MUST NOT be possible to reverse, or
   brute-force, the process and recover the ID.

#. It MUST NOT be possible to use the same Key Blob for multiple
   Mobile Devices.

#. The implementation SHOULD use mechanisms that are already available
   in the existing Bootloader. This limits us to the use of SHA-256
   and/or RSA.

Implementation
==============

This section describes the implementation for anonymizing the
Device Binding. The description is limited to that isolated use case; more
specifically, this document does not describe the Locking process
as a whole.

Provisioning
------------

A Key Blob needs to be generated, by the Server, for each unique
Mobile Device, individually. Sending the Device Binding to the Server would
allow the Server to track individual devices. To avoid this, instead
of sending the Device Binding in plaintext, it is converted into a 256-bit
MAC, using HMAC-SHA-256, as described in [RFC2104]_ and [SHS]_, before
it is sent to the Server.

#. The User\ [#ulf]_ retrieves the Device Binding from the Mobile Device.

#. The User generates a key to be used for computing a HMAC of the
   Device Binding. The key MUST be 256 bits in size, as recommended (for
   HMAC-SHA-256) by [RFC2104]_. It MUST also be chosen at random, or
   generated by a cryptographically strong pseudo-random generator.

#. The HMAC, together with the desired public key\ [#pubkey]_ and
   various metadata, is sent to the Server. The exact structure of the
   message is intentionally left out of this specification, but it is
   important that it MUST NOT contain any information that could lead
   to the exposure of the Device Binding.

#. When the Server receives a valid request, it generates, based on
   the information in the request, a Key Blob containing the desired
   public key and the HMAC, signs it, and returns the signed Key Blob
   to the User.

#. The User writes the Key Blob and the HMAC key into the Mobile
   Device. The exact storage mechanism used is intentionally left out
   of this document.

This process is illustrated in :ref:`provisioning`.

.. _provisioning:

.. uml::
   :align: center
   :caption: Key Blob Provisioning Sequence

   hide footbox

   participant "Mobile Device" as ldr
   actor User as ulf
   participant Server as srv

   activate ulf

   ulf -> ldr: get_id()
   activate ldr
   ldr -> ulf: id
   deactivate ldr

   ulf -> ulf: k = random_key()

   ulf -> srv: {pubkey, hmac-sha-256(id, k), â€¦}
   activate srv
   srv -> ulf: keyblob
   deactivate srv

   ulf -> ldr: {keyblob, k}
   activate ldr
   ldr -> ulf: Ok
   deactivate ldr

   deactivate ulf

Device Boot
-----------

When the Mobile Device is subsequently started, the Key Blob is used
to authenticate several pieces of software, including, but not
necessarily limited to, the Linux kernel for the Android
system. During this process, the HMAC is again computed, using the key
that was previously written into the device, and compared to the HMAC
in the loaded Key Blob. If they match, the boot process continues; if
not, the boot process MUST halt.

.. rubric:: Footnotes

.. [#ulf] In practice, the User will automate the process using a tool

.. [#pubkey] Multiple public keys and/or public key certificates may
             be sent, depending on the situation
